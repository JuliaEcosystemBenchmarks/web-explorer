<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Julia Ecosystem Benchmarks Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #495057;
        }
        
        select, input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metrics-section {
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }
        
        .metrics-title {
            text-align: center;
            font-weight: 700;
            font-size: 18px;
            margin-bottom: 20px;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .metric-charts {
            display: grid;
            gap: 15px;
        }
        
        .chart-container {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            background: white;
            position: relative;
        }
        
        .chart-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 15px;
            color: #495057;
        }
        
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }
        
        .zoom-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            transition: background-color 0.2s;
        }
        
        .zoom-btn:hover {
            background: #e9ecef;
        }
        
        .zoom-btn:active {
            background: #dee2e6;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .axis {
            color: #495057;
        }
        
        .axis-label {
            font-size: 12px;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }
        
        .spinner-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(2px);
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2c3e50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .spinner-text {
            margin-left: 15px;
            font-size: 16px;
            color: #2c3e50;
            font-weight: 600;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none !important;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Julia Ecosystem Benchmarks Explorer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="packageSelect">Package</label>
                <select id="packageSelect" multiple size="6">
                    <option value="all">All Packages</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="taskSelect">Task</label>
                <select id="taskSelect" multiple size="6">
                    <option value="all">All Tasks</option>
                </select>
            </div>
            
        </div>
        
        <div class="charts-container">
            <!-- Time Metrics Column -->
            <div class="metrics-section">
                <div class="metrics-title">Time Metrics</div>
                <div class="metric-charts">
                    <div class="chart-container">
                        <div class="zoom-controls">
                            <div class="zoom-btn" onclick="zoomChart('precompileTimeChart', 1.5)" title="Zoom In">+</div>
                            <div class="zoom-btn" onclick="zoomChart('precompileTimeChart', 0.67)" title="Zoom Out">−</div>
                            <div class="zoom-btn" onclick="resetZoom('precompileTimeChart')" title="Reset Zoom">⌂</div>
                        </div>
                        <div class="chart-title">Precompile Time (seconds)</div>
                        <svg id="precompileTimeChart" width="550" height="300"></svg>
                    </div>
                    
                    <div class="chart-container">
                        <div class="zoom-controls">
                            <div class="zoom-btn" onclick="zoomChart('loadingTimeChart', 1.5)" title="Zoom In">+</div>
                            <div class="zoom-btn" onclick="zoomChart('loadingTimeChart', 0.67)" title="Zoom Out">−</div>
                            <div class="zoom-btn" onclick="resetZoom('loadingTimeChart')" title="Reset Zoom">⌂</div>
                        </div>
                        <div class="chart-title">Loading Time (seconds)</div>
                        <svg id="loadingTimeChart" width="550" height="300"></svg>
                    </div>
                    
                    <div class="chart-container">
                        <div class="zoom-controls">
                            <div class="zoom-btn" onclick="zoomChart('taskTimeChart', 1.5)" title="Zoom In">+</div>
                            <div class="zoom-btn" onclick="zoomChart('taskTimeChart', 0.67)" title="Zoom Out">−</div>
                            <div class="zoom-btn" onclick="resetZoom('taskTimeChart')" title="Reset Zoom">⌂</div>
                        </div>
                        <div class="chart-title">Task Time (seconds)</div>
                        <svg id="taskTimeChart" width="550" height="300"></svg>
                    </div>
                </div>
            </div>
            
            <!-- Memory Metrics Column -->
            <div class="metrics-section">
                <div class="metrics-title">Memory Metrics</div>
                <div class="metric-charts">
                    <div class="chart-container">
                        <div class="zoom-controls">
                            <div class="zoom-btn" onclick="zoomChart('precompileMemoryChart', 1.5)" title="Zoom In">+</div>
                            <div class="zoom-btn" onclick="zoomChart('precompileMemoryChart', 0.67)" title="Zoom Out">−</div>
                            <div class="zoom-btn" onclick="resetZoom('precompileMemoryChart')" title="Reset Zoom">⌂</div>
                        </div>
                        <div class="chart-title">Precompile Memory (KB)</div>
                        <svg id="precompileMemoryChart" width="550" height="300"></svg>
                    </div>
                    
                    <div class="chart-container">
                        <div class="zoom-controls">
                            <div class="zoom-btn" onclick="zoomChart('taskMemoryChart', 1.5)" title="Zoom In">+</div>
                            <div class="zoom-btn" onclick="zoomChart('taskMemoryChart', 0.67)" title="Zoom Out">−</div>
                            <div class="zoom-btn" onclick="resetZoom('taskMemoryChart')" title="Reset Zoom">⌂</div>
                        </div>
                        <div class="chart-title">Task Memory (KB)</div>
                        <svg id="taskMemoryChart" width="550" height="300"></svg>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="legend" id="legend"></div>
        
        <div class="loading" id="loading">Loading Julia ecosystem benchmark data...</div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Spinner overlay -->
    <div class="spinner-container hidden" id="spinner">
        <div class="spinner"></div>
        <div class="spinner-text" id="spinnerText">Loading data...</div>
    </div>

    <script>
        // Global variables
        let data = [];
        let filteredData = [];
        let juliaVersions = [];
        let colorScale;
        
        // Chart dimensions and margins
        const margin = { top: 20, right: 30, bottom: 50, left: 70 };
        const width = 550 - margin.left - margin.right;
        const height = 300 - margin.top - margin.bottom;
        
        // Define all metrics and their configurations
        const metrics = {
            precompileTimeChart: { accessor: 'precompile_time', label: 'Time (seconds)', title: 'Precompile Time' },
            loadingTimeChart: { accessor: 'loading_time', label: 'Time (seconds)', title: 'Loading Time' },
            taskTimeChart: { accessor: 'task_time', label: 'Time (seconds)', title: 'Task Time' },
            precompileMemoryChart: { accessor: 'precompile_resident', label: 'Memory (KB)', title: 'Precompile Memory' },
            taskMemoryChart: { accessor: 'task_resident', label: 'Memory (KB)', title: 'Task Memory' }
        };
        
        // Zoom state tracking for all charts
        let chartZoomStates = {};
        Object.keys(metrics).forEach(chartId => {
            chartZoomStates[chartId] = { transform: d3.zoomIdentity };
        });
        
        // Special non-numeric version names (add here as needed)
        const specialVersions = ['nightly', 'dev', 'rc', 'alpha', 'beta'];
        
        // Spinner utility functions
        function showSpinner(message = 'Loading...') {
            console.log('Showing spinner:', message);
            const spinner = document.getElementById('spinner');
            const spinnerText = document.getElementById('spinnerText');
            
            if (spinner && spinnerText) {
                spinnerText.textContent = message;
                spinner.classList.remove('hidden');
            }
        }
        
        function hideSpinner() {
            console.log('Hiding spinner');
            const spinner = document.getElementById('spinner');
            if (spinner) {
                spinner.classList.add('hidden');
            }
        }
        
        // URL anchor management
        function updateURLAnchor() {
            const selectedPackages = Array.from(document.getElementById('packageSelect').selectedOptions)
                .map(option => option.value);
            const selectedTasks = Array.from(document.getElementById('taskSelect').selectedOptions)
                .map(option => option.value);
            
            console.log('Updating URL anchor with selections:', { packages: selectedPackages, tasks: selectedTasks });
            
            // Create URL anchor with selections
            const anchorData = {
                packages: selectedPackages.filter(p => p !== 'all'), // Exclude 'all' from URL
                tasks: selectedTasks.filter(t => t !== 'all') // Exclude 'all' from URL
            };
            
            // Only include non-empty arrays
            const urlParams = new URLSearchParams();
            if (anchorData.packages.length > 0) {
                urlParams.set('packages', anchorData.packages.join(','));
            }
            if (anchorData.tasks.length > 0) {
                urlParams.set('tasks', anchorData.tasks.join(','));
            }
            
            // Update URL without triggering page reload
            const newAnchor = urlParams.toString();
            const newURL = window.location.pathname + (newAnchor ? '#' + newAnchor : '');
            
            console.log('Setting URL to:', newURL);
            window.history.replaceState(null, '', newURL);
        }
        
        function parseURLAnchor() {
            console.log('Parsing URL anchor...');
            const hash = window.location.hash.substring(1); // Remove the '#'
            
            if (!hash) {
                console.log('No URL anchor found');
                return { packages: [], tasks: [] };
            }
            
            const urlParams = new URLSearchParams(hash);
            
            const packages = urlParams.get('packages');
            const tasks = urlParams.get('tasks');
            
            const result = {
                packages: packages ? packages.split(',').filter(p => p.trim()) : [],
                tasks: tasks ? tasks.split(',').filter(t => t.trim()) : []
            };
            
            console.log('Parsed URL anchor:', result);
            return result;
        }
        
        function restoreSelectionsFromURL() {
            console.log('Restoring selections from URL...');
            const urlSelections = parseURLAnchor();
            
            if (urlSelections.packages.length === 0 && urlSelections.tasks.length === 0) {
                console.log('No URL selections to restore');
                return false;
            }
            
            // Validate that data is loaded
            if (!data || data.length === 0) {
                console.warn('Cannot restore URL selections: data not loaded');
                return false;
            }
            
            // Get available packages and tasks
            const availablePackages = [...new Set(data.map(d => d.package_name))];
            const availableTasks = [...new Set(data.map(d => d.task_name))];
            
            console.log('Available packages:', availablePackages.length);
            console.log('Available tasks:', availableTasks.length);
            
            // Filter URL selections to only include items that exist in the data
            const validPackages = urlSelections.packages.filter(pkg => availablePackages.includes(pkg));
            const validTasks = urlSelections.tasks.filter(task => availableTasks.includes(task));
            
            console.log('Valid packages from URL:', validPackages);
            console.log('Valid tasks from URL:', validTasks);
            
            // If no valid selections, clear the URL
            if (validPackages.length === 0 && validTasks.length === 0) {
                console.log('No valid selections found in URL, clearing anchor');
                window.history.replaceState(null, '', window.location.pathname);
                return false;
            }
            
            // Restore package selections
            const packageSelect = document.getElementById('packageSelect');
            if (!packageSelect) {
                console.error('Package selector not found');
                return false;
            }
            
            Array.from(packageSelect.options).forEach(option => {
                option.selected = validPackages.includes(option.value);
            });
            
            // Update task selector based on selected packages
            if (validPackages.length > 0) {
                populateTaskSelector(validPackages);
            } else {
                populateTaskSelector([]);
            }
            
            // Restore task selections (after task selector is updated)
            setTimeout(() => {
                const taskSelect = document.getElementById('taskSelect');
                if (!taskSelect) {
                    console.error('Task selector not found');
                    return;
                }
                
                Array.from(taskSelect.options).forEach(option => {
                    option.selected = validTasks.includes(option.value);
                });
                
                console.log('Selections restored from URL successfully');
                
                // Filter data and update charts (filterData will handle its own spinner)
                filterData();
            }, 100);
            
            return true;
        }
        
        // Handle browser back/forward buttons
        function handlePopState() {
            console.log('Browser navigation detected, restoring selections from URL');
            if (data && data.length > 0) {
                restoreSelectionsFromURL();
            }
        }
        
        // Extract minor version for color grouping (e.g., "1.8.0" -> "1.8", "nightly" -> "nightly")
        function getMinorVersion(version) {
            // Check if it's a special version
            const isSpecial = specialVersions.some(sv => version.toLowerCase().includes(sv));
            if (isSpecial) {
                return version; // Keep special versions as-is
            }
            
            // For numeric versions, extract major.minor (e.g., "1.8.0" -> "1.8")
            const parts = version.split('.');
            if (parts.length >= 2) {
                return `${parts[0]}.${parts[1]}`;
            }
            return version; // Fallback for unexpected formats
        }
        
        // Define available marker shapes
        const markerShapes = [
            'circle', 'square', 'triangle', 'diamond', 'cross', 'star', 
            'pentagon', 'hexagon', 'plus', 'x'
        ];
        
        // Get shape for package (using package name hash)
        function getPackageShape(packageName) {
            const hash = packageName.split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0);
            return markerShapes[Math.abs(hash) % markerShapes.length];
        }
        
        // Get shape for task (using task name hash)
        function getTaskShape(taskName) {
            const hash = taskName.split('').reduce((a, b) => {
                a = ((a << 7) - a) + b.charCodeAt(0); // Different multiplier for variety
                return a & a;
            }, 0);
            return markerShapes[Math.abs(hash) % markerShapes.length];
        }
        
        // Function to create different marker shapes
        function createMarker(selection, shape, size = 4) {
            selection.each(function(d) {
                const element = d3.select(this);
                const x = parseFloat(element.attr('data-x')) || 0;
                const y = parseFloat(element.attr('data-y')) || 0;
                
                // Clear existing content
                element.selectAll('*').remove();
                
                // Set the transform to position the group
                element.attr('transform', `translate(${x},${y})`);
                
                switch(shape) {
                    case 'circle':
                        element.append('circle')
                            .attr('r', size);
                        break;
                    case 'square':
                        element.append('rect')
                            .attr('x', -size).attr('y', -size)
                            .attr('width', size * 2).attr('height', size * 2);
                        break;
                    case 'triangle':
                        element.append('polygon')
                            .attr('points', `0,${-size} ${-size},${size} ${size},${size}`);
                        break;
                    case 'diamond':
                        element.append('polygon')
                            .attr('points', `0,${-size} ${size},0 0,${size} ${-size},0`);
                        break;
                    case 'cross':
                        element.append('path')
                            .attr('d', `M${-size},-1 L${size},-1 L${size},1 L${-size},1 Z M-1,${-size} L1,${-size} L1,${size} L-1,${size} Z`);
                        break;
                    case 'star':
                        const starPoints = [];
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI) / 5;
                            const radius = i % 2 === 0 ? size : size / 2;
                            starPoints.push(`${radius * Math.cos(angle - Math.PI/2)},${radius * Math.sin(angle - Math.PI/2)}`);
                        }
                        element.append('polygon')
                            .attr('points', starPoints.join(' '));
                        break;
                    case 'pentagon':
                        const pentagonPoints = [];
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI) / 5;
                            pentagonPoints.push(`${size * Math.cos(angle - Math.PI/2)},${size * Math.sin(angle - Math.PI/2)}`);
                        }
                        element.append('polygon')
                            .attr('points', pentagonPoints.join(' '));
                        break;
                    case 'hexagon':
                        const hexagonPoints = [];
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            hexagonPoints.push(`${size * Math.cos(angle)},${size * Math.sin(angle)}`);
                        }
                        element.append('polygon')
                            .attr('points', hexagonPoints.join(' '));
                        break;
                    case 'plus':
                        element.append('path')
                            .attr('d', `M${-size},-1 L${size},-1 L${size},1 L${-size},1 Z M-1,${-size} L1,${-size} L1,${size} L-1,${size} Z`);
                        break;
                    case 'x':
                        const s = size * 0.7; // Make X slightly smaller
                        element.append('path')
                            .attr('d', `M${-s},${-s} L${-s/2},${-s} L0,${-s/2} L${s/2},${-s} L${s},${-s} L${s},${-s/2} L${s/2},0 L${s},${s/2} L${s},${s} L${s/2},${s} L0,${s/2} L${-s/2},${s} L${-s},${s} L${-s},${s/2} L${-s/2},0 L${-s},${-s/2} Z`);
                        break;
                    default:
                        element.append('circle')
                            .attr('r', size);
                }
            });
        }
        
        // Load and parse CSV data
        async function loadData() {
            try {
                console.log('Starting data load...');
                showSpinner('Loading Julia ecosystem benchmark data...');
                
                const csvData = await d3.csv('https://raw.githubusercontent.com/JuliaEcosystemBenchmarks/julia-ecosystem-benchmarks/refs/heads/jeb_logs/data/Julia-TTFX-Snippets/ttfx_snippets_data.csv');
                
                console.log('CSV data loaded, raw data sample:', csvData.slice(0, 3));
                console.log('Total CSV rows loaded:', csvData.length);
                
                if (!csvData || csvData.length === 0) {
                    throw new Error('No data received from CSV');
                }
                
                data = csvData.map(d => ({
                    package_name: d.package_name,
                    task_name: d.task_name,
                    date: new Date(d.date),
                    julia_version: d.julia_version,
                    hostname: d.hostname,
                    hash: d.hash,
                    precompile_time: +d.precompile_time,
                    loading_time: +d.loading_time,
                    task_time: +d.task_time,
                    precompile_cpu: +d.precompile_cpu,
                    task_cpu: +d.task_cpu,
                    precompile_resident: +d.precompile_resident / 1024, // Convert to KB
                    task_resident: +d.task_resident / 1024 // Convert to KB
                }));
                
                console.log('Data processed, sample processed data:', data.slice(0, 3));
                console.log('Total processed rows:', data.length);
                
                showSpinner('Setting up visualization...');
                
                // Extract and sort Julia versions from the data
                extractJuliaVersions();
                setupColorScale();
                
                populateSelectors();
                filteredData = [...data];
                console.log('Initial filtered data length:', filteredData.length);
                
                // Try to restore selections from URL anchor
                const urlRestored = restoreSelectionsFromURL();
                
                // If no URL selections were restored, create charts with default data
                if (!urlRestored) {
                    showSpinner('Creating charts...');
                    createAllCharts();
                }
                
                createLegend();
                document.getElementById('loading').style.display = 'none';
                hideSpinner();
                
            } catch (error) {
                console.error('Error loading data:', error);
                hideSpinner();
                document.getElementById('loading').textContent = 'Error loading data. Please check the data source.';
            }
        }
        
        function extractJuliaVersions() {
            console.log('Extracting Julia versions from data...');
            
            // Get unique full versions from the data
            const uniqueFullVersions = [...new Set(data.map(d => d.julia_version))];
            console.log('Found unique full versions:', uniqueFullVersions);
            
            // Get unique minor versions for color grouping
            const uniqueMinorVersions = [...new Set(uniqueFullVersions.map(getMinorVersion))];
            console.log('Found unique minor versions:', uniqueMinorVersions);
            
            // Sort minor versions: numeric versions first (sorted properly), then special versions
            juliaVersions = uniqueMinorVersions.sort((a, b) => {
                const aIsSpecial = specialVersions.some(sv => a.toLowerCase().includes(sv));
                const bIsSpecial = specialVersions.some(sv => b.toLowerCase().includes(sv));
                
                // Both special - alphabetical
                if (aIsSpecial && bIsSpecial) {
                    return a.localeCompare(b);
                }
                
                // One special, one not - special goes last
                if (aIsSpecial && !bIsSpecial) return 1;
                if (!aIsSpecial && bIsSpecial) return -1;
                
                // Both numeric - proper version sorting
                const aVersion = a.split('.').map(Number);
                const bVersion = b.split('.').map(Number);
                for (let i = 0; i < Math.max(aVersion.length, bVersion.length); i++) {
                    const aPart = aVersion[i] || 0;
                    const bPart = bVersion[i] || 0;
                    if (aPart !== bPart) return aPart - bPart;
                }
                return 0;
            });
            
            console.log('Sorted Julia minor versions for coloring:', juliaVersions);
        }
        
        function setupColorScale() {
            console.log('Setting up color scale for', juliaVersions.length, 'minor versions');
            
            // Create a comprehensive color palette
            const colors = d3.schemeCategory10
                .concat(d3.schemeDark2)
                .concat(d3.schemeSet3)
                .concat(d3.schemeAccent);
            
            // Map minor versions to colors
            colorScale = d3.scaleOrdinal()
                .domain(juliaVersions)
                .range(colors);
                
            console.log('Color scale configured for minor versions:', juliaVersions);
        }
        
        function getTasksForPackages(selectedPackages) {
            console.log('Getting tasks for packages:', selectedPackages);
            
            if (!selectedPackages || selectedPackages.length === 0 || selectedPackages.includes('all')) {
                // If no packages selected or "all" selected, return all tasks
                return [...new Set(data.map(d => d.task_name))].sort();
            }
            
            // Filter data to selected packages and get their tasks
            const filteredTasks = data
                .filter(d => selectedPackages.includes(d.package_name))
                .map(d => d.task_name);
                
            const uniqueTasks = [...new Set(filteredTasks)].sort();
            console.log(`Found ${uniqueTasks.length} tasks for selected packages:`, uniqueTasks);
            
            return uniqueTasks;
        }
        
        function populatePackageSelector() {
            console.log('Populating package selector...');
            
            const packages = [...new Set(data.map(d => d.package_name))].sort();
            console.log('Unique packages found:', packages.length);
            
            const packageSelect = document.getElementById('packageSelect');
            
            // Clear existing options except "All Packages"
            while (packageSelect.children.length > 1) {
                packageSelect.removeChild(packageSelect.lastChild);
            }
            
            packages.forEach(pkg => {
                const option = document.createElement('option');
                option.value = pkg;
                option.textContent = pkg;
                packageSelect.appendChild(option);
            });
            
            console.log('Package selector populated successfully');
        }
        
        function populateTaskSelector(selectedPackages = []) {
            console.log('Populating task selector...');
            
            const taskSelect = document.getElementById('taskSelect');
            
            // Store current selections
            const currentSelections = Array.from(taskSelect.selectedOptions).map(option => option.value);
            
            // Clear existing options except "All Tasks"
            while (taskSelect.children.length > 1) {
                taskSelect.removeChild(taskSelect.lastChild);
            }
            
            const availableTasks = getTasksForPackages(selectedPackages);
            console.log('Available tasks for selection:', availableTasks.length);
            
            availableTasks.forEach(task => {
                const option = document.createElement('option');
                option.value = task;
                option.textContent = task;
                
                // Restore selection if the task is still available
                if (currentSelections.includes(task)) {
                    option.selected = true;
                }
                
                taskSelect.appendChild(option);
            });
            
            console.log('Task selector populated successfully');
        }
        
        function populateSelectors() {
            console.log('Populating selectors...');
            console.log('Data available for selectors:', data.length, 'rows');
            
            populatePackageSelector();
            populateTaskSelector(); // Initially populate with all tasks
            
            console.log('Selectors populated successfully');
        }
        
        function onPackageSelectionChange() {
            console.log('Package selection changed');
            const selectedPackages = Array.from(document.getElementById('packageSelect').selectedOptions)
                .map(option => option.value);
            
            console.log('Selected packages:', selectedPackages);
            
            // Handle "All Packages" selection logic
            const packageSelect = document.getElementById('packageSelect');
            if (selectedPackages.includes('all')) {
                // If "All Packages" is selected, deselect individual packages
                Array.from(packageSelect.options).forEach(option => {
                    if (option.value !== 'all') {
                        option.selected = false;
                    }
                });
                // Update the selected packages array
                selectedPackages.length = 0;
                selectedPackages.push('all');
            } else if (selectedPackages.length > 1 && selectedPackages.includes('all')) {
                // If individual packages are selected along with "All", deselect "All"
                Array.from(packageSelect.options).forEach(option => {
                    if (option.value === 'all') {
                        option.selected = false;
                    }
                });
                // Remove "all" from selected packages
                const allIndex = selectedPackages.indexOf('all');
                if (allIndex > -1) {
                    selectedPackages.splice(allIndex, 1);
                }
            }
            
            // Update task selector based on new package selection
            populateTaskSelector(selectedPackages);
            
            // Filter and update charts
            filterData();
            
            // Update URL anchor
            updateURLAnchor();
        }
        
        function onTaskSelectionChange() {
            console.log('Task selection changed');
            const selectedTasks = Array.from(document.getElementById('taskSelect').selectedOptions)
                .map(option => option.value);
            
            console.log('Selected tasks:', selectedTasks);
            
            // Handle "All Tasks" selection logic
            const taskSelect = document.getElementById('taskSelect');
            if (selectedTasks.includes('all')) {
                // If "All Tasks" is selected, deselect individual tasks
                Array.from(taskSelect.options).forEach(option => {
                    if (option.value !== 'all') {
                        option.selected = false;
                    }
                });
            } else if (selectedTasks.length > 1 && selectedTasks.includes('all')) {
                // If individual tasks are selected along with "All", deselect "All"
                Array.from(taskSelect.options).forEach(option => {
                    if (option.value === 'all') {
                        option.selected = false;
                    }
                });
            }
            
            // Filter and update charts
            filterData();
            
            // Update URL anchor
            updateURLAnchor();
        }
        
        function filterData() {
            console.log('Filtering data...');
            showSpinner('Filtering data...');
            
            const selectedPackages = Array.from(document.getElementById('packageSelect').selectedOptions)
                .map(option => option.value);
            const selectedTasks = Array.from(document.getElementById('taskSelect').selectedOptions)
                .map(option => option.value);
            
            console.log('Selected packages:', selectedPackages);
            console.log('Selected tasks:', selectedTasks);
            
            // Use setTimeout to allow spinner to show before heavy computation
            setTimeout(() => {
                filteredData = data.filter(d => {
                    const packageMatch = selectedPackages.length === 0 || 
                        selectedPackages.includes('all') || 
                        selectedPackages.includes(d.package_name);
                        
                    const taskMatch = selectedTasks.length === 0 || 
                        selectedTasks.includes('all') || 
                        selectedTasks.includes(d.task_name);
                        
                    return packageMatch && taskMatch;
                });
                
                console.log('Filtered data length:', filteredData.length);
                
                showSpinner('Updating charts...');
                
                // Use another timeout to allow spinner message to update
                setTimeout(() => {
                    createAllCharts();
                    hideSpinner();
                }, 10);
            }, 10);
        }
        
        function createChart(svgId, yAccessor, title, yLabel) {
            console.log(`Creating chart for ${svgId}...`);
            console.log('Filtered data for chart:', filteredData.length, 'points');
            
            const svg = d3.select(`#${svgId}`);
            svg.selectAll('*').remove();
            
            if (!filteredData || filteredData.length === 0) {
                console.log(`No data available for ${svgId}, skipping chart creation`);
                return;
            }
            
            console.log('Sample filtered data for chart:', filteredData.slice(0, 3));
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Scales
            const xExtent = d3.extent(filteredData, d => d.date);
            const yValues = filteredData.map(yAccessor).filter(v => isFinite(v));
            
            if (yValues.length === 0) {
                console.error(`No valid y values for ${svgId}`);
                return;
            }
            
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);
            const yMean = d3.mean(yValues);
            
            // Set y upper limit to min(slightly above max, 4 * mean)
            const yUpperLimit = Math.min(yMax * 1.05, yMean * 4);
            const yExtent = [Math.max(0, yMin * 0.95), yUpperLimit]; // Start from 0 or slightly below min
            
            console.log(`${svgId} - X extent (dates):`, xExtent);
            console.log(`${svgId} - Y values: min=${yMin.toFixed(2)}, max=${yMax.toFixed(2)}, mean=${yMean.toFixed(2)}`);
            console.log(`${svgId} - Y limit: ${yUpperLimit.toFixed(2)} (max*1.05=${(yMax*1.05).toFixed(2)}, mean*4=${(yMean*4).toFixed(2)})`);
            console.log(`${svgId} - Final Y extent:`, yExtent);
            
            if (!xExtent[0] || !xExtent[1] || !isFinite(yExtent[0]) || !isFinite(yExtent[1])) {
                console.error(`Invalid extent for ${svgId}:`, { xExtent, yExtent });
                return;
            }
            
            // Apply zoom transform to scales
            const transform = chartZoomStates[svgId].transform;
            
            const xScale = d3.scaleTime()
                .domain(xExtent)
                .range([0, width]);
            
            const yScale = d3.scaleLinear()
                .domain(yExtent)
                .range([height, 0]);
            
            // Create zoomed scales
            const zoomedXScale = transform.rescaleX(xScale);
            const zoomedYScale = transform.rescaleY(yScale);
            
            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(zoomedXScale).tickFormat(d3.timeFormat('%Y-%m')))
                .attr('class', 'axis')
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            g.append('g')
                .call(d3.axisLeft(zoomedYScale))
                .attr('class', 'axis');
            
            // Axis labels
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .text(yLabel);
            
            g.append('text')
                .attr('transform', `translate(${width / 2}, ${height + margin.bottom - 5})`)
                .style('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .text('Date');
            
            // Tooltip
            const tooltip = d3.select('#tooltip');
            
            // Data points
            console.log(`Creating ${filteredData.length} data points for ${svgId}`);
            
            const dataPoints = g.selectAll('.dot')
                .data(filteredData);
                
            console.log('Data binding completed for', svgId);
            
            const enteringPoints = dataPoints.enter().append('g')
                .attr('class', 'dot')
                .style('fill', d => colorScale(getMinorVersion(d.julia_version)))
                .style('opacity', 0.7)
                .style('cursor', 'pointer')
                .attr('data-x', d => {
                    const x = zoomedXScale(d.date);
                    if (!isFinite(x)) console.warn('Invalid x position:', d.date, x);
                    return x;
                })
                .attr('data-y', d => {
                    const y = zoomedYScale(yAccessor(d));
                    if (!isFinite(y)) console.warn('Invalid y position:', yAccessor(d), y);
                    return y;
                })
                .each(function(d) {
                    const element = d3.select(this);
                    const x = parseFloat(element.attr('data-x'));
                    const y = parseFloat(element.attr('data-y'));
                    
                    // Use package name to determine shape (can also use task name)
                    const shape = getPackageShape(d.package_name);
                    
                    element.attr('data-x', x).attr('data-y', y);
                    createMarker(element, shape, 4);
                })
                .on('mouseover', function(event, d) {
                    d3.select(this).style('opacity', 1);
                    // Scale up the marker on hover
                    const shape = getPackageShape(d.package_name);
                    createMarker(d3.select(this), shape, 6);
                    
                    tooltip.style('opacity', 1)
                        .html(`
                            <strong>${d.package_name}</strong><br/>
                            Task: ${d.task_name}<br/>
                            Julia: ${d.julia_version}<br/>
                            Date: ${d.date.toDateString()}<br/>
                            Value: ${yAccessor(d).toFixed(2)}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function(d) {
                    d3.select(this).style('opacity', 0.7);
                    // Scale back down
                    const shape = getPackageShape(d.package_name);
                    createMarker(d3.select(this), shape, 4);
                    tooltip.style('opacity', 0);
                });
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', function(event) {
                    chartZoomStates[svgId].transform = event.transform;
                    updateChartWithZoom(svgId);
                });
            
            svg.call(zoom);
                
            console.log(`Chart ${svgId} creation completed`);
        }
        
        function createAllCharts() {
            console.log('Creating all charts...');
            
            Object.keys(metrics).forEach(chartId => {
                const metric = metrics[chartId];
                const yAccessor = d => d[metric.accessor];
                
                console.log(`Creating ${chartId} with accessor ${metric.accessor}`);
                createChart(chartId, yAccessor, metric.title, metric.label);
            });
            
            console.log('All charts created successfully');
        }
        
        function createLegend() {
            console.log('Creating legend...');
            const legend = d3.select('#legend');
            legend.selectAll('*').remove();
            
            if (!data || data.length === 0 || !juliaVersions || juliaVersions.length === 0) {
                console.log('No data or versions available for legend');
                return;
            }
            
            console.log('Creating legend for minor versions:', juliaVersions);
            
            // Get full versions for each minor version to show the grouping
            const fullVersions = [...new Set(data.map(d => d.julia_version))];
            
            juliaVersions.forEach(minorVersion => {
                const item = legend.append('div').attr('class', 'legend-item');
                item.append('div')
                    .attr('class', 'legend-color')
                    .style('background-color', colorScale(minorVersion));
                
                // Show which patch versions are included in this color group
                const patchVersions = fullVersions.filter(fullVer => getMinorVersion(fullVer) === minorVersion);
                const versionText = patchVersions.length > 1 
                    ? `Julia ${minorVersion}.x (${patchVersions.join(', ')})`
                    : `Julia ${minorVersion}`;
                
                item.append('span').text(versionText);
            });
            
            console.log('Legend created successfully');
        }
        
        // Zoom functions
        function updateChartWithZoom(svgId) {
            console.log(`Updating zoom for ${svgId}`);
            
            if (metrics[svgId]) {
                const metric = metrics[svgId];
                const yAccessor = d => d[metric.accessor];
                createChart(svgId, yAccessor, metric.title, metric.label);
            }
        }
        
        function zoomChart(svgId, scaleFactor) {
            console.log(`Zooming ${svgId} by factor ${scaleFactor}`);
            const svg = d3.select(`#${svgId}`);
            const currentTransform = chartZoomStates[svgId].transform;
            
            // Calculate new transform
            const newTransform = currentTransform.scale(scaleFactor);
            chartZoomStates[svgId].transform = newTransform;
            
            // Update the zoom behavior and chart
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', function(event) {
                    chartZoomStates[svgId].transform = event.transform;
                    updateChartWithZoom(svgId);
                });
            
            svg.call(zoom.transform, newTransform);
        }
        
        function resetZoom(svgId) {
            console.log(`Resetting zoom for ${svgId}`);
            chartZoomStates[svgId].transform = d3.zoomIdentity;
            
            const svg = d3.select(`#${svgId}`);
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', function(event) {
                    chartZoomStates[svgId].transform = event.transform;
                    updateChartWithZoom(svgId);
                });
            
            svg.call(zoom.transform, d3.zoomIdentity);
        }
        
        // Event listeners
        document.getElementById('packageSelect').addEventListener('change', onPackageSelectionChange);
        document.getElementById('taskSelect').addEventListener('change', onTaskSelectionChange);
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', handlePopState);
        
        // Initialize
        loadData();
    </script>
</body>
</html>