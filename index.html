<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Julia Ecosystem Benchmarks Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #495057;
        }
        
        select, input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            background: white;
        }
        
        .chart-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 15px;
            color: #495057;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .axis {
            color: #495057;
        }
        
        .axis-label {
            font-size: 12px;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Julia Ecosystem Benchmarks Explorer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="packageSelect">Package</label>
                <select id="packageSelect" multiple size="6">
                    <option value="all">All Packages</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="taskSelect">Task</label>
                <select id="taskSelect" multiple size="6">
                    <option value="all">All Tasks</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="timeMetric">Time Metric</label>
                <select id="timeMetric">
                    <option value="precompile_time">Precompile Time</option>
                    <option value="loading_time">Loading Time</option>
                    <option value="task_time">Task Time</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="memoryMetric">Memory Metric</label>
                <select id="memoryMetric">
                    <option value="precompile_resident">Precompile Memory</option>
                    <option value="task_resident">Task Memory</option>
                </select>
            </div>
        </div>
        
        <div class="charts-container">
            <div class="chart-container">
                <div class="chart-title" id="timeChartTitle">Time Performance Over Date</div>
                <svg id="timeChart" width="600" height="400"></svg>
            </div>
            
            <div class="chart-container">
                <div class="chart-title" id="memoryChartTitle">Memory Usage Over Date</div>
                <svg id="memoryChart" width="600" height="400"></svg>
            </div>
        </div>
        
        <div class="legend" id="legend"></div>
        
        <div class="loading" id="loading">Loading Julia ecosystem benchmark data...</div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global variables
        let data = [];
        let filteredData = [];
        let juliaVersions = [];
        let colorScale;
        
        // Chart dimensions and margins
        const margin = { top: 20, right: 30, bottom: 60, left: 80 };
        const width = 600 - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;
        
        // Special non-numeric version names (add here as needed)
        const specialVersions = ['nightly', 'dev', 'rc', 'alpha', 'beta'];
        
        // Extract minor version for color grouping (e.g., "1.8.0" -> "1.8", "nightly" -> "nightly")
        function getMinorVersion(version) {
            // Check if it's a special version
            const isSpecial = specialVersions.some(sv => version.toLowerCase().includes(sv));
            if (isSpecial) {
                return version; // Keep special versions as-is
            }
            
            // For numeric versions, extract major.minor (e.g., "1.8.0" -> "1.8")
            const parts = version.split('.');
            if (parts.length >= 2) {
                return `${parts[0]}.${parts[1]}`;
            }
            return version; // Fallback for unexpected formats
        }
        
        // Load and parse CSV data
        async function loadData() {
            try {
                console.log('Starting data load...');
                const csvData = await d3.csv('https://raw.githubusercontent.com/JuliaEcosystemBenchmarks/julia-ecosystem-benchmarks/refs/heads/jeb_logs/data/Julia-TTFX-Snippets/ttfx_snippets_data.csv');
                
                console.log('CSV data loaded, raw data sample:', csvData.slice(0, 3));
                console.log('Total CSV rows loaded:', csvData.length);
                
                if (!csvData || csvData.length === 0) {
                    throw new Error('No data received from CSV');
                }
                
                data = csvData.map(d => ({
                    package_name: d.package_name,
                    task_name: d.task_name,
                    date: new Date(d.date),
                    julia_version: d.julia_version,
                    hostname: d.hostname,
                    hash: d.hash,
                    precompile_time: +d.precompile_time,
                    loading_time: +d.loading_time,
                    task_time: +d.task_time,
                    precompile_cpu: +d.precompile_cpu,
                    task_cpu: +d.task_cpu,
                    precompile_resident: +d.precompile_resident / 1024, // Convert to KB
                    task_resident: +d.task_resident / 1024 // Convert to KB
                }));
                
                console.log('Data processed, sample processed data:', data.slice(0, 3));
                console.log('Total processed rows:', data.length);
                
                // Extract and sort Julia versions from the data
                extractJuliaVersions();
                setupColorScale();
                
                populateSelectors();
                filteredData = [...data];
                console.log('Initial filtered data length:', filteredData.length);
                
                updateCharts();
                createLegend();
                document.getElementById('loading').style.display = 'none';
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').textContent = 'Error loading data. Please check the data source.';
            }
        }
        
        function extractJuliaVersions() {
            console.log('Extracting Julia versions from data...');
            
            // Get unique full versions from the data
            const uniqueFullVersions = [...new Set(data.map(d => d.julia_version))];
            console.log('Found unique full versions:', uniqueFullVersions);
            
            // Get unique minor versions for color grouping
            const uniqueMinorVersions = [...new Set(uniqueFullVersions.map(getMinorVersion))];
            console.log('Found unique minor versions:', uniqueMinorVersions);
            
            // Sort minor versions: numeric versions first (sorted properly), then special versions
            juliaVersions = uniqueMinorVersions.sort((a, b) => {
                const aIsSpecial = specialVersions.some(sv => a.toLowerCase().includes(sv));
                const bIsSpecial = specialVersions.some(sv => b.toLowerCase().includes(sv));
                
                // Both special - alphabetical
                if (aIsSpecial && bIsSpecial) {
                    return a.localeCompare(b);
                }
                
                // One special, one not - special goes last
                if (aIsSpecial && !bIsSpecial) return 1;
                if (!aIsSpecial && bIsSpecial) return -1;
                
                // Both numeric - proper version sorting
                const aVersion = a.split('.').map(Number);
                const bVersion = b.split('.').map(Number);
                for (let i = 0; i < Math.max(aVersion.length, bVersion.length); i++) {
                    const aPart = aVersion[i] || 0;
                    const bPart = bVersion[i] || 0;
                    if (aPart !== bPart) return aPart - bPart;
                }
                return 0;
            });
            
            console.log('Sorted Julia minor versions for coloring:', juliaVersions);
        }
        
        function setupColorScale() {
            console.log('Setting up color scale for', juliaVersions.length, 'minor versions');
            
            // Create a comprehensive color palette
            const colors = d3.schemeCategory10
                .concat(d3.schemeDark2)
                .concat(d3.schemeSet3)
                .concat(d3.schemeAccent);
            
            // Map minor versions to colors
            colorScale = d3.scaleOrdinal()
                .domain(juliaVersions)
                .range(colors);
                
            console.log('Color scale configured for minor versions:', juliaVersions);
        }
        
        function populateSelectors() {
            console.log('Populating selectors...');
            console.log('Data available for selectors:', data.length, 'rows');
            
            const packages = [...new Set(data.map(d => d.package_name))].sort();
            const tasks = [...new Set(data.map(d => d.task_name))].sort();
            
            console.log('Unique packages found:', packages.length);
            console.log('Unique tasks found:', tasks.length);
            console.log('Sample packages:', packages.slice(0, 5));
            console.log('Sample tasks:', tasks.slice(0, 5));
            
            const packageSelect = document.getElementById('packageSelect');
            const taskSelect = document.getElementById('taskSelect');
            
            packages.forEach(pkg => {
                const option = document.createElement('option');
                option.value = pkg;
                option.textContent = pkg;
                packageSelect.appendChild(option);
            });
            
            tasks.forEach(task => {
                const option = document.createElement('option');
                option.value = task;
                option.textContent = task;
                taskSelect.appendChild(option);
            });
            
            console.log('Selectors populated successfully');
        }
        
        function filterData() {
            console.log('Filtering data...');
            const selectedPackages = Array.from(document.getElementById('packageSelect').selectedOptions)
                .map(option => option.value);
            const selectedTasks = Array.from(document.getElementById('taskSelect').selectedOptions)
                .map(option => option.value);
            
            console.log('Selected packages:', selectedPackages);
            console.log('Selected tasks:', selectedTasks);
            
            filteredData = data.filter(d => {
                const packageMatch = selectedPackages.length === 0 || 
                    selectedPackages.includes('all') || 
                    selectedPackages.includes(d.package_name);
                    
                const taskMatch = selectedTasks.length === 0 || 
                    selectedTasks.includes('all') || 
                    selectedTasks.includes(d.task_name);
                    
                return packageMatch && taskMatch;
            });
            
            console.log('Filtered data length:', filteredData.length);
            updateCharts();
        }
        
        function createChart(svgId, yAccessor, title, yLabel) {
            console.log(`Creating chart for ${svgId}...`);
            console.log('Filtered data for chart:', filteredData.length, 'points');
            
            const svg = d3.select(`#${svgId}`);
            svg.selectAll('*').remove();
            
            if (!filteredData || filteredData.length === 0) {
                console.log(`No data available for ${svgId}, skipping chart creation`);
                return;
            }
            
            console.log('Sample filtered data for chart:', filteredData.slice(0, 3));
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Scales
            const xExtent = d3.extent(filteredData, d => d.date);
            const yExtent = d3.extent(filteredData, yAccessor);
            
            console.log(`${svgId} - X extent (dates):`, xExtent);
            console.log(`${svgId} - Y extent:`, yExtent);
            
            if (!xExtent[0] || !xExtent[1] || !isFinite(yExtent[0]) || !isFinite(yExtent[1])) {
                console.error(`Invalid extent for ${svgId}:`, { xExtent, yExtent });
                return;
            }
            
            const xScale = d3.scaleTime()
                .domain(xExtent)
                .range([0, width]);
            
            const yScale = d3.scaleLinear()
                .domain(yExtent)
                .nice()
                .range([height, 0]);
            
            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%Y-%m')))
                .attr('class', 'axis')
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            g.append('g')
                .call(d3.axisLeft(yScale))
                .attr('class', 'axis');
            
            // Axis labels
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .text(yLabel);
            
            g.append('text')
                .attr('transform', `translate(${width / 2}, ${height + margin.bottom - 5})`)
                .style('text-anchor', 'middle')
                .attr('class', 'axis-label')
                .text('Date');
            
            // Tooltip
            const tooltip = d3.select('#tooltip');
            
            // Data points
            console.log(`Creating ${filteredData.length} data points for ${svgId}`);
            
            const dataPoints = g.selectAll('.dot')
                .data(filteredData);
                
            console.log('Data binding completed for', svgId);
                
            dataPoints.enter().append('circle')
                .attr('class', 'dot')
                .attr('cx', d => {
                    const x = xScale(d.date);
                    if (!isFinite(x)) console.warn('Invalid x position:', d.date, x);
                    return x;
                })
                .attr('cy', d => {
                    const y = yScale(yAccessor(d));
                    if (!isFinite(y)) console.warn('Invalid y position:', yAccessor(d), y);
                    return y;
                })
                .attr('r', 4)
                .style('fill', d => colorScale(getMinorVersion(d.julia_version)))
                .style('opacity', 0.7)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('r', 6);
                    tooltip.style('opacity', 1)
                        .html(`
                            <strong>${d.package_name}</strong><br/>
                            Task: ${d.task_name}<br/>
                            Julia: ${d.julia_version}<br/>
                            Date: ${d.date.toDateString()}<br/>
                            Value: ${yAccessor(d).toFixed(2)}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    d3.select(this).attr('r', 4);
                    tooltip.style('opacity', 0);
                });
                
            console.log(`Chart ${svgId} creation completed`);
        }
        
        function updateCharts() {
            console.log('Updating charts...');
            const timeMetric = document.getElementById('timeMetric').value;
            const memoryMetric = document.getElementById('memoryMetric').value;
            
            console.log('Selected metrics - Time:', timeMetric, 'Memory:', memoryMetric);
            
            const timeAccessor = d => d[timeMetric];
            const memoryAccessor = d => d[memoryMetric];
            
            // Test accessors with sample data
            if (filteredData.length > 0) {
                const sampleData = filteredData[0];
                console.log('Sample data for accessor test:', sampleData);
                console.log('Time accessor result:', timeAccessor(sampleData));
                console.log('Memory accessor result:', memoryAccessor(sampleData));
            }
            
            const timeTitle = `${timeMetric.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())} Over Time`;
            const memoryTitle = `${memoryMetric.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())} Over Time`;
            
            document.getElementById('timeChartTitle').textContent = timeTitle;
            document.getElementById('memoryChartTitle').textContent = memoryTitle;
            
            console.log('About to create charts...');
            createChart('timeChart', timeAccessor, timeTitle, 
                timeMetric.includes('time') ? 'Time (seconds)' : 'CPU Usage');
            createChart('memoryChart', memoryAccessor, memoryTitle, 'Memory (KB)');
            console.log('Charts update completed');
        }
        
        function createLegend() {
            console.log('Creating legend...');
            const legend = d3.select('#legend');
            legend.selectAll('*').remove();
            
            if (!data || data.length === 0 || !juliaVersions || juliaVersions.length === 0) {
                console.log('No data or versions available for legend');
                return;
            }
            
            console.log('Creating legend for minor versions:', juliaVersions);
            
            // Get full versions for each minor version to show the grouping
            const fullVersions = [...new Set(data.map(d => d.julia_version))];
            
            juliaVersions.forEach(minorVersion => {
                const item = legend.append('div').attr('class', 'legend-item');
                item.append('div')
                    .attr('class', 'legend-color')
                    .style('background-color', colorScale(minorVersion));
                
                // Show which patch versions are included in this color group
                const patchVersions = fullVersions.filter(fullVer => getMinorVersion(fullVer) === minorVersion);
                const versionText = patchVersions.length > 1 
                    ? `Julia ${minorVersion}.x (${patchVersions.join(', ')})`
                    : `Julia ${minorVersion}`;
                
                item.append('span').text(versionText);
            });
            
            console.log('Legend created successfully');
        }
        
        // Event listeners
        document.getElementById('packageSelect').addEventListener('change', filterData);
        document.getElementById('taskSelect').addEventListener('change', filterData);
        document.getElementById('timeMetric').addEventListener('change', updateCharts);
        document.getElementById('memoryMetric').addEventListener('change', updateCharts);
        
        // Initialize
        loadData();
    </script>
</body>
</html>